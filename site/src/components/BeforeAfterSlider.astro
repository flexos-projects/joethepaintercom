```astro
---
import { getUniqueId } from '../utils/uniqueId';

interface Props {
  beforeImage: { src: string; alt: string; };
  afterImage: { src: string; alt: string; };
  class?: string;
}

const { beforeImage, afterImage, class: className } = Astro.props;

const sliderId = getUniqueId('before-after-slider');
const handleId = getUniqueId('slider-handle');
---

<div
  id={sliderId}
  class:list={[
    'relative w-full overflow-hidden group select-none touch-pan-x',
    'rounded-lg shadow-md',
    'aspect-video', // Maintain aspect ratio for common video sizes
    className
  ]}
  role="group"
  aria-label="Before and after image comparison"
  tabindex="0"
>
  <img
    src={beforeImage.src}
    alt={beforeImage.alt}
    class="absolute inset-0 w-full h-full object-cover z-10"
    draggable="false"
  />
  <img
    src={afterImage.src}
    alt={afterImage.alt}
    class="absolute inset-0 w-full h-full object-cover z-20"
    style="clip-path: inset(0 0 0 50%);"
    draggable="false"
  />

  <!-- Handle -->
  <div
    id={handleId}
    class="absolute top-0 bottom-0 w-1 bg-white z-30 flex items-center justify-center cursor-ew-resize
           shadow-lg transition-colors duration-200 group-hover:bg-primary-light"
    style="left: 50%; transform: translateX(-50%);"
    role="slider"
    aria-label="Image comparison slider"
    aria-valuenow="50"
    aria-valuemin="0"
    aria-valuemax="100"
    tabindex="0"
  >
    <div class="w-8 h-8 rounded-full bg-white flex items-center justify-center text-neutral-700
                shadow-md group-hover:bg-primary-light group-hover:text-white transition-colors duration-200">
      <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M8 7l4-4m0 0l4 4m-4-4v18"></path>
      </svg>
    </div>
  </div>
</div>

<script define:vars={{ sliderId, handleId }} is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const sliderContainer = document.getElementById(sliderId);
    const handle = document.getElementById(handleId);
    const afterImage = sliderContainer?.querySelector('img:last-of-type');
    let isDragging = false;

    if (!sliderContainer || !handle || !afterImage) return;

    const updateSlider = (clientX) => {
      const rect = sliderContainer.getBoundingClientRect();
      let x = clientX - rect.left;
      x = Math.max(0, Math.min(x, rect.width));

      const percentage = (x / rect.width) * 100;

      handle.style.left = `${percentage}%`;
      afterImage.style.clipPath = `inset(0 0 0 ${percentage}%)`;
      handle.setAttribute('aria-valuenow', Math.round(percentage).toString());
    };

    const onMouseMove = (e) => {
      if (!isDragging) return;
      updateSlider(e.clientX);
    };

    const onTouchMove = (e) => {
      if (!isDragging || !e.touches[0]) return;
      updateSlider(e.touches[0].clientX);
    };

    const onMouseUp = () => {
      isDragging = false;
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    const onTouchEnd = () => {
      isDragging = false;
      document.removeEventListener('touchmove', onTouchMove);
      document.removeEventListener('touchend', onTouchEnd);
    };

    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    handle.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      document.addEventListener('touchmove', onTouchMove);
      document.addEventListener('touchend', onTouchEnd);
    }, { passive: false });

    // Keyboard navigation for handle
    handle.addEventListener('keydown', (e) => {
      const step = 5; // Move by 5%
      const rect = sliderContainer.getBoundingClientRect();
      const currentLeft = parseFloat(handle.style.left); // Percentage
      let newLeft = currentLeft;

      if (e.key === 'ArrowLeft') {
        newLeft = Math.max(0, currentLeft - step);
        e.preventDefault();
      } else if (e.key === 'ArrowRight') {
        newLeft = Math.min(100, currentLeft + step);
        e.preventDefault();
      } else if (e.key === 'Home') {
        newLeft = 0;
        e.preventDefault();
      } else if (e.key === 'End') {
        newLeft = 100;
        e.preventDefault();
      }

      if (newLeft !== currentLeft) {
        handle.style.left = `${newLeft}%`;
        afterImage.style.clipPath = `inset(0 0 0 ${newLeft}%)`;
        handle.setAttribute('aria-valuenow', Math.round(newLeft).toString());
      }
    });

    // Initial positioning
    updateSlider(sliderContainer.getBoundingClientRect().width / 2 + sliderContainer.getBoundingClientRect().left);
  });
</script>
```
---