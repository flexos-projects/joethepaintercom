```astro
---
import type { ImageMetadata } from 'astro';
import { Image } from 'astro:assets';
import { v4 as uuidv4 } from 'uuid'; // For unique IDs if multiple sliders on one page

interface Props {
  beforeImage: ImageMetadata;
  afterImage: ImageMetadata;
  alt: string;
}

const { beforeImage, afterImage, alt } = Astro.props;
const sliderId = `before-after-slider-${uuidv4()}`; // Unique ID for each slider
---

<div class="relative w-full overflow-hidden rounded-lg group" id={sliderId}>
  <!-- Before Image -->
  <Image
    src={beforeImage}
    alt={`Before: ${alt}`}
    loading="lazy"
    class="w-full h-full object-cover absolute top-0 left-0"
  />

  <!-- After Image -->
  <Image
    src={afterImage}
    alt={`After: ${alt}`}
    loading="lazy"
    class="w-full h-full object-cover absolute top-0 left-0"
    style={{ clipPath: 'inset(0 0 0 50%)' }}
    id={`${sliderId}-after-image`}
  />

  <!-- Slider Handle -->
  <div
    class="absolute top-0 bottom-0 w-2 bg-surface flex items-center justify-center cursor-ew-resize shadow-md
           motion-safe:transition-all motion-reduce:transition-none duration-100 ease-linear
           group-hover:w-8 group-focus-within:w-8"
    style={{ left: 'calc(50% - 1px)' }}
    id={`${sliderId}-handle`}
    role="slider"
    aria-valuenow="50"
    aria-valuemin="0"
    aria-valuemax="100"
    aria-label="Drag to compare before and after images"
    tabindex="0"
  >
    <svg class="w-6 h-6 text-primary" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z" clip-rule="evenodd"></path>
    </svg>
  </div>
</div>

<script is:inline>
  function initializeBeforeAfterSlider(sliderElementId) {
    const slider = document.getElementById(sliderElementId);
    if (!slider) return;

    const handle = slider.querySelector(`#${sliderElementId}-handle`);
    const afterImage = slider.querySelector(`#${sliderElementId}-after-image`);
    let isDragging = false;

    if (!handle || !afterImage) return;

    function moveHandle(clientX) {
      const rect = slider.getBoundingClientRect();
      let x = clientX - rect.left; // X position relative to the slider
      x = Math.max(0, Math.min(x, rect.width)); // Constrain x within slider bounds

      const percentage = (x / rect.width) * 100;
      handle.style.left = `${x}px`;
      afterImage.style.clipPath = `inset(0 0 0 ${x}px)`;
      handle.setAttribute('aria-valuenow', Math.round(percentage).toString());
    }

    // Mouse events
    handle.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      slider.classList.add('cursor-ew-resize');
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      moveHandle(e.clientX);
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        slider.classList.remove('cursor-ew-resize');
      }
    });

    // Touch events
    handle.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      slider.classList.add('cursor-ew-resize');
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (!isDragging || !e.touches[0]) return;
      moveHandle(e.touches[0].clientX);
    }, { passive: false });

    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        slider.classList.remove('cursor-ew-resize');
      }
    });

    // Keyboard navigation for accessibility
    handle.addEventListener('keydown', (e) => {
      const step = 5; // Pixels to move per key press
      const rect = slider.getBoundingClientRect();
      let currentLeft = parseFloat(handle.style.left) || (rect.width / 2);

      if (e.key === 'ArrowLeft' || e.key === 'Left') {
        e.preventDefault();
        moveHandle(rect.left + currentLeft - step);
      } else if (e.key === 'ArrowRight' || e.key === 'Right') {
        e.preventDefault();
        moveHandle(rect.left + currentLeft + step);
      }
    });

    // Initial positioning
    moveHandle(slider.getBoundingClientRect().left + slider.getBoundingClientRect().width / 2);
  }

  // Initialize all sliders on the page
  document.querySelectorAll('[id^="before-after-slider-"]').forEach(slider => {
    initializeBeforeAfterSlider(slider.id);
  });
</script>
```