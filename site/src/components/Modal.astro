---
import { createPortal } from 'astro/jsx-runtime';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'div'> {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  description?: string;
}

const { isOpen, onClose, title, description, class: className, ...rest } = Astro.props;

// Unique IDs for accessibility
const modalId = `modal-${Math.random().toString(36).substring(2, 9)}`;
const titleId = `${modalId}-title`;
const descriptionId = `${modalId}-description`;

// Client-side script for modal functionality (focus trap, escape key, etc.)
// This script will run on the client as soon as the component is hydrated.
---
{
  isOpen && createPortal(
    <div
      class="fixed inset-0 z-[9999] flex items-center justify-center p-4 md:p-8"
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      aria-describedby={descriptionId}
      tabindex="-1"
      id={modalId}
      {...rest}
    >
      {/* Backdrop */}
      <div
        class="fixed inset-0 bg-black bg-opacity-60 transition-opacity duration-normal ease-default motion-reduce:transition-none animate-fade-in"
        onClick={onClose}
        aria-hidden="true"
      ></div>

      {/* Modal Content */}
      <div
        class:list={[
          'relative bg-surface rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto',
          'transform transition-all duration-normal ease-default motion-reduce:transition-none animate-scale-in',
          className
        ]}
        role="document"
      >
        <div class="flex items-center justify-between p-4 md:p-6 border-b border-border">
          <h2 id={titleId} class="font-heading text-2xl font-bold text-text">
            {title}
          </h2>
          <button
            class="p-2 text-text hover:text-primary transition-all-colors-transform"
            onClick={onClose}
            aria-label="Close modal"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {description && <p id={descriptionId} class="sr-only">{description}</p>}

        <div class="p-4 md:p-6">
          <slot />
        </div>
      </div>
    </div>,
    document.body // Portal to body for correct z-index and focus management
  )
}

<script define:vars={{ modalId }} is:inline>
  const modalElement = document.getElementById(modalId);
  const focusableElementsSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
  let previouslyFocusedElement;
  let firstFocusableElement;
  let lastFocusableElement;

  function handleOpen() {
    if (!modalElement) return;

    previouslyFocusedElement = document.activeElement;
    modalElement.focus(); // Focus the modal itself

    const focusableContent = modalElement.querySelectorAll(focusableElementsSelector);
    firstFocusableElement = focusableContent[0];
    lastFocusableElement = focusableContent[focusableContent.length - 1];

    firstFocusableElement?.focus(); // Focus the first focusable element inside the modal

    document.body.style.overflow = 'hidden'; // Prevent scrolling on body
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('focusin', enforceFocus); // Enforce focus within modal
  }

  function handleClose() {
    if (!modalElement) return;

    document.body.style.overflow = ''; // Restore scrolling on body
    document.removeEventListener('keydown', handleKeyDown);
    document.removeEventListener('focusin', enforceFocus);
    previouslyFocusedElement?.focus(); // Return focus to where it was
  }

  function handleKeyDown(event) {
    if (event.key === 'Escape') {
      // Assuming onClose is globally accessible or passed via a custom event
      // For this example, we'll dispatch a custom event that parent can listen to
      modalElement.dispatchEvent(new CustomEvent('modalCloseRequest'));
    }
    if (event.key === 'Tab') {
      if (event.shiftKey) { // if shift + tab
        if (document.activeElement === firstFocusableElement) {
          lastFocusableElement.focus();
          event.preventDefault();
        }
      } else { // if tab
        if (document.activeElement === lastFocusableElement) {
          firstFocusableElement.focus();
          event.preventDefault();
        }
      }
    }
  }

  function enforceFocus(event) {
    if (!modalElement.contains(event.target)) {
      event.stopPropagation();
      firstFocusableElement?.focus();
    }
  }

  // Listener for custom close event from parent (Astro component)
  // This is a simplified way to manage state across Astro components.
  // In a real app, you'd use a more robust state management or framework component.
  modalElement?.addEventListener('modalCloseRequest', () => {
    // The parent component's `onClose` prop needs to be called.
    // Astro's server-side rendering makes direct JS calls to parent props tricky.
    // For this example, we'll assume the `onClose` function is directly available
    // or that the parent component re-renders `isOpen=false` based on some state.
    // For now, we'll just handle the cleanup.
    handleClose();
    // A more robust solution for Astro would be to wrap the modal in a framework component
    // (e.g., React) to manage its internal state and emit events.
  });


  // Observe changes to the `aria-hidden` attribute if `isOpen` is toggled by parent Astro
  const observer = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
        if (modalElement.getAttribute('aria-hidden') === 'false' && modalElement.offsetParent !== null) {
          handleOpen();
        } else if (modalElement.getAttribute('aria-hidden') === 'true') {
          handleClose();
        }
      }
    }
  });

  if (modalElement) {
    observer.observe(modalElement, { attributes: true });
    // Initial check if modal is open on page load (e.g., if set to true by default)
    if (modalElement.getAttribute('aria-hidden') === 'false' && modalElement.offsetParent !== null) {
      handleOpen();
    }
  }

</script>
---