---
import { createPortal } from 'astro/jsx-runtime';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'div'> {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  description?: string;
}

const { isOpen, onClose, title, description, class: className, ...rest } = Astro.props;

// Unique IDs for accessibility
const modalId = `modal-${Math.random().toString(36).substring(2, 9)}`;
const titleId = `${modalId}-title`;
const descriptionId = `${modalId}-description`;

// Client-side script for modal functionality (focus trap, escape key, etc.)
// This script will run on the client as soon as the component is hydrated.
---
{
  isOpen && createPortal(
    <div
      class="fixed inset-0 z-[9999] flex items-center justify-center p-4 md:p-8"
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      aria-describedby={descriptionId}
      tabindex="-1"
      id={modalId}
      {...rest}
    >
      {/* Backdrop */}
      <div
        class="fixed inset-0 bg-black bg-opacity-60 transition-opacity duration-normal ease-default motion-reduce:transition-none animate-fade-in"
        onClick={onClose}
        aria-hidden="true"
      ></div>

      {/* Modal Content */}
      <div
        class:list={[
          'relative bg-surface rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto',
          'transform transition-all duration-normal ease-default motion-reduce:transition-none animate-scale-in',
          className
        ]}
        role="document"
      >
        <div class="flex items-center justify-between p-4 md:p-6 border-b border-border">
          <h2 id={titleId} class="font-heading text-2xl font-bold text-text">
            {title}
          </h2>
          <button
            class="p-2 text-text hover:text-primary transition-colors duration-150 ease-in-out motion-reduce:transition-none"
            onClick={onClose}
            aria-label="Close modal"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {description && <p id={descriptionId} class="sr-only">{description}</p>}

        <div class="p-4 md:p-6">
          <slot />
        </div>
      </div>
    </div>,
    document.body // Portal to body for correct z-index and focus management
  )
}

<script define:vars={{ modalId }} is:inline>
  // These variables will retain their state for the lifetime of the script (while modal is mounted)
  let previouslyFocusedElement = null;
  let firstFocusableElement = null;
  let lastFocusableElement = null;

  const modalElement = document.getElementById(modalId);
  const focusableElementsSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';

  const handleKeyDown = (event) => {
    if (event.key === 'Escape') {
      // Dispatch custom event for parent to listen to and call its onClose prop
      // Parent is responsible for reacting to this event, calling its onClose,
      // which should then handle body scroll restoration and focus return.
      modalElement?.dispatchEvent(new CustomEvent('modalCloseRequest', { bubbles: true }));
    }
    if (event.key === 'Tab') {
      if (firstFocusableElement && lastFocusableElement) { // Ensure elements are defined
        if (event.shiftKey) { // if shift + tab
          if (document.activeElement === firstFocusableElement) {
            lastFocusableElement.focus();
            event.preventDefault();
          }
        } else { // if tab
          if (document.activeElement === lastFocusableElement) {
            firstFocusableElement.focus();
            event.preventDefault();
          }
        }
      }
    }
  };

  const enforceFocus = (event) => {
    // If focus moves outside the modal, return it to the first focusable element
    if (modalElement && !modalElement.contains(event.target)) {
      event.stopPropagation();
      firstFocusableElement?.focus();
    }
  };

  // Logic to run when the modal is mounted (script executes)
  if (modalElement) {
    previouslyFocusedElement = document.activeElement; // Capture focus on mount

    modalElement.focus(); // Focus the modal itself initially for keyboard trap

    const focusableContent = modalElement.querySelectorAll(focusableElementsSelector);
    firstFocusableElement = focusableContent[0];
    lastFocusableElement = focusableContent[focusableContent.length - 1];

    firstFocusableElement?.focus(); // Focus the first focusable element inside the modal

    document.body.style.overflow = 'hidden'; // Prevent scrolling on body

    // Add event listeners
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('focusin', enforceFocus);

    // IMPORTANT: The parent component using this Modal is responsible for cleanup.
    // When the modal is closed (via button click or parent handling `modalCloseRequest`):
    // 1. The parent must set `isOpen` to `false` to unmount this component.
    // 2. The parent's `onClose` function (or a separate cleanup function) MUST explicitly:
    //    - Restore `document.body.style.overflow = '';`
    //    - Restore `previouslyFocusedElement?.focus();`
    //    - Remove `document.removeEventListener('keydown', handleKeyDown);`
    //    - Remove `document.removeEventListener('focusin', enforceFocus);`
    // This contract ensures full accessibility and proper resource management.
  }
</script>
---