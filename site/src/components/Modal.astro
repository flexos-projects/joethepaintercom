---
// Modal.astro
// Accessible and reusable modal component with focus trapping and keyboard navigation.

interface Props {
  isOpen: boolean;
  onClose: () => void;
  titleId: string; // ID for the modal title element
  contentId: string; // ID for the modal content element
  title: string;
  class?: string; // Additional classes for the modal content div
}

const { isOpen, onClose, titleId, contentId, title, class: additionalClass } = Astro.props;

// This script handles the modal's accessibility features:
// - Focus trapping: Keeps keyboard focus within the modal when open.
// - Escape key: Closes the modal.
// - aria attributes: Communicates modal state to screen readers.
// - Scroll locking: Prevents body scrolling when modal is open.
// - Focus restoration: Returns focus to the element that opened the modal.
---

<div
  class:list={[
    'fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-300 ease-out',
    isOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'
  ]}
  role="dialog"
  aria-modal="true"
  aria-labelledby={titleId}
  aria-describedby={contentId}
  tabindex="-1"
  data-modal-open={isOpen.toString()}
>
  <!-- Backdrop -->
  <div
    class="absolute inset-0 bg-black bg-opacity-50"
    aria-hidden="true"
    onclick={onClose}
  ></div>

  <!-- Modal Content -->
  <div
    class:list={[
      'relative bg-white rounded-lg shadow-xl max-w-lg w-full p-6 sm:p-8 transition-transform duration-300 ease-out z-50',
      isOpen ? 'scale-100 opacity-100' : 'scale-95 opacity-0',
      additionalClass
    ]}
    role="document"
  >
    <h2 id={titleId} class="text-2xl font-heading font-bold text-neutral-800 mb-4">
      {title}
    </h2>
    <button
      type="button"
      class="absolute top-4 right-4 text-neutral-500 hover:text-neutral-800 p-2 rounded-full focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
      aria-label="Close modal"
      onclick={onClose}
    >
      <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
      </svg>
    </button>
    <div id={contentId}>
      <slot />
    </div>
  </div>
</div>

<script define:vars={{ isOpen }} is:inline>
  const modal = document.querySelector('[data-modal-open="true"]');
  const focusableElements = 'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';

  let previouslyFocusedElement;

  function handleOpenModal() {
    if (!modal) return;

    previouslyFocusedElement = document.activeElement;
    document.body.style.overflow = 'hidden'; // Prevent scrolling body

    // Delay focus to ensure modal is fully rendered and visible
    setTimeout(() => {
      const focusable = modal.querySelectorAll(focusableElements);
      if (focusable.length > 0) {
        (focusable[0] as HTMLElement).focus();
      } else {
        modal.focus(); // Fallback focus on modal itself
      }
    }, 100); // Small delay to allow transition

    modal.addEventListener('keydown', trapFocus);
  }

  function handleCloseModal() {
    if (!modal) return;

    document.body.style.overflow = ''; // Restore body scrolling
    modal.removeEventListener('keydown', trapFocus);
    if (previouslyFocusedElement) {
      (previouslyFocusedElement as HTMLElement).focus();
    }
  }

  function trapFocus(event) {
    if (event.key !== 'Tab') return;

    const focusable = modal.querySelectorAll(focusableElements);
    const firstFocusable = focusable[0];
    const lastFocusable = focusable[focusable.length - 1];

    if (event.shiftKey) { // Shift + Tab
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        event.preventDefault();
      }
    } else { // Tab
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        event.preventDefault();
      }
    }
  }

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && modal && modal.getAttribute('data-modal-open') === 'true') {
      window.onClose(); // Call the Astro component's onClose prop
    }
  });

  // Observe changes to the isOpen prop
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'data-modal-open') {
        const currentIsOpen = modal.getAttribute('data-modal-open') === 'true';
        if (currentIsOpen) {
          handleOpenModal();
        } else {
          handleCloseModal();
        }
      }
    });
  });

  if (modal) {
    observer.observe(modal, { attributes: true });
  }

  // Initial setup if modal is open on page load (though typically modals are closed initially)
  if (isOpen) {
    handleOpenModal();
  }
</script>