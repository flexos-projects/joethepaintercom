```astro
---
import { getUniqueId } from '../utils/uniqueId'; // Assuming a utility for unique IDs

interface Props {
  isOpen: boolean;
  onClose: () => void;
  titleId?: string;
  descriptionId?: string;
  label?: string; // Accessible label for the modal
  class?: string;
}

const {
  isOpen,
  onClose,
  titleId = getUniqueId('modal-title'),
  descriptionId = getUniqueId('modal-description'),
  label = 'Dialog', // Fallback label
  class: className,
} = Astro.props;

// Use client:visible to only hydrate when the modal is potentially needed
// Or use client:only="react" if using a React modal implementation
// For a pure Astro/JS solution, inline script will handle show/hide
---

{isOpen && (
  <div
    role="dialog"
    aria-modal="true"
    aria-labelledby={titleId}
    aria-describedby={descriptionId}
    class:list={[
      'fixed inset-0 z-[100] flex items-center justify-center p-4 md:p-6',
      'animate-fade-in-slow' // Assuming an animation is defined in global.css or tailwind.config
    ]}
    tabindex="-1"
  >
    <!-- Backdrop -->
    <div
      class="absolute inset-0 bg-black bg-opacity-50 transition-opacity duration-300"
      aria-hidden="true"
      onclick={onClose}
    ></div>

    <!-- Modal Content -->
    <div
      class:list={[
        'relative bg-white rounded-lg shadow-xl max-w-lg w-full max-h-[90vh] overflow-y-auto',
        'p-6 sm:p-8 md:p-10',
        'transform scale-95 opacity-0 animate-scale-in-fast', // Assuming animations
        className
      ]}
      role="document"
    >
      <button
        onclick={onClose}
        class="absolute top-4 right-4 p-2 rounded-full text-neutral-700 hover:bg-neutral-100 hover:text-primary
               focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
        aria-label={`Close ${label}`}
      >
        <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>

      <!-- Modal title and content slot -->
      <h2 id={titleId} class="text-2xl font-heading font-bold text-neutral-900 mb-4 pr-10">
        <slot name="title" />
      </h2>
      <div id={descriptionId}>
        <slot />
      </div>
    </div>
  </div>
)}

<script define:vars={{ isOpen }} is:inline>
  const modalElement = document.querySelector('[role="dialog"][aria-modal="true"]');
  let currentFocusedElement = null; // To store the element that had focus before the modal opened

  function trapFocus(event) {
    if (!modalElement || !isOpen) return;

    const focusableElements = modalElement.querySelectorAll(
      'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );
    const firstFocusableElement = focusableElements[0];
    const lastFocusableElement = focusableElements[focusableElements.length - 1];

    if (event.key === 'Tab') {
      if (event.shiftKey) { // Shift + Tab
        if (document.activeElement === firstFocusableElement) {
          lastFocusableElement.focus();
          event.preventDefault();
        }
      } else { // Tab
        if (document.activeElement === lastFocusableElement) {
          firstFocusableElement.focus();
          event.preventDefault();
        }
      }
    }
  }

  function handleKeydown(event) {
    if (event.key === 'Escape' && isOpen) {
      event.stopPropagation(); // Prevent other escape listeners
      onClose(); // Call the onClose prop passed to the component
    }
  }

  // Effect for when isOpen changes
  if (isOpen) {
    currentFocusedElement = document.activeElement; // Store currently focused element
    document.addEventListener('keydown', handleKeydown);
    document.addEventListener('keydown', trapFocus);
    document.body.classList.add('overflow-hidden'); // Prevent background scroll

    // Focus the first element in the modal or the modal itself
    const firstFocusable = modalElement?.querySelector(
      'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );
    if (firstFocusable) {
      firstFocusable.focus();
    } else {
      modalElement?.focus(); // Focus the modal itself if no interactive elements
    }
  } else {
    document.removeEventListener('keydown', handleKeydown);
    document.removeEventListener('keydown', trapFocus);
    document.body.classList.remove('overflow-hidden');

    // Restore focus to the element that was focused before the modal opened
    if (currentFocusedElement && currentFocusedElement.focus) {
      currentFocusedElement.focus();
      currentFocusedElement = null;
    }
  }
</script>
```
---