---
import Input from './ui/Input.astro';
import Label from './ui/Label.astro';
import Button from './ui/Button.astro';
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'form'> {
  formId?: string;
  ctaText?: string;
}

const { formId = 'contact-form', ctaText = 'Send My Message', ...attrs } = Astro.props;
---

<form id={formId} class="space-y-6" {...attrs}>
  <div>
    <Label for="yourName">Your Name</Label>
    <Input
      id="yourName"
      name="yourName"
      type="text"
      placeholder="Jane Doe"
      required
      minLength={2}
    />
    <p id="yourName-error" class="hidden text-error text-sm mt-1"></p>
  </div>
  <div>
    <Label for="yourEmail">Your Email</Label>
    <Input
      id="yourEmail"
      name="yourEmail"
      type="email"
      placeholder="jane.doe@example.com"
      required
    />
    <p id="yourEmail-error" class="hidden text-error text-sm mt-1"></p>
  </div>
  <div>
    <Label for="subject">Subject</Label>
    <Input
      id="subject"
      name="subject"
      type="text"
      placeholder="Question about painting"
      required
      minLength={5}
    />
    <p id="subject-error" class="hidden text-error text-sm mt-1"></p>
  </div>
  <div>
    <Label for="yourMessage">Your Message</Label>
    <textarea
      id="yourMessage"
      name="yourMessage"
      rows={5}
      placeholder="Ask your question here."
      required
      minLength={10}
      maxLength={1000}
      class="w-full px-4 py-3 border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent bg-surface text-text text-base transition-colors duration-200"
      aria-describedby="yourMessage-error"
    ></textarea>
    <p id="yourMessage-error" class="hidden text-error text-sm mt-1"></p>
  </div>

  <!-- Hidden reCAPTCHA field -->
  <input type="hidden" name="g-recaptcha-response" id="g-recaptcha-response-contact" />

  <Button type="submit" variant="primary" size="lg" class="w-full">
    {ctaText}
  </Button>
  <p id="form-submission-error-contact" class="hidden text-error text-sm text-center mt-4" role="alert"></p>
</form>

<script is:inline>
  const formContact = document.getElementById('contact-form');
  const submitButtonContact = formContact?.querySelector('button[type="submit"]');
  const recaptchaInputContact = document.getElementById('g-recaptcha-response-contact');
  const formSubmissionErrorContact = document.getElementById('form-submission-error-contact');

  // Basic client-side validation display
  const validateField = (input) => {
    const errorElement = document.getElementById(`${input.id}-error`);
    if (!errorElement) return true;

    if (input.checkValidity()) {
      errorElement.classList.add('hidden');
      input.classList.remove('border-error');
      return true;
    } else {
      // Provide a more user-friendly message for common validation errors
      let message = input.validationMessage;
      if (input.type === 'email' && input.value !== '' && !input.validity.valid) {
        message = 'Please enter a valid email address.';
      } else if (input.validity.valueMissing) {
        message = 'This field is required.';
      } else if (input.validity.tooShort) {
        message = `Please lengthen this text to ${input.minLength} characters or more (you are currently using ${input.value.length} characters).`;
      } else if (input.id === 'subject' && input.validity.tooShort) {
        message = 'Subject must be at least 5 characters.';
      } else if (input.id === 'yourMessage' && input.validity.tooShort) {
        message = 'Message must be at least 10 characters.';
      } else if (input.id === 'yourName' && input.validity.tooShort) {
        message = 'Name must be at least 2 characters.';
      }

      errorElement.textContent = message;
      errorElement.classList.remove('hidden');
      input.classList.add('border-error');
      return false;
    }
  };

  formContact?.addEventListener('input', (event) => {
    validateField(event.target as HTMLInputElement | HTMLTextAreaElement); // Explicitly cast event.target
  });
  
  formContact?.addEventListener('blur', (event) => { // Add blur event for immediate feedback
    validateField(event.target as HTMLInputElement | HTMLTextAreaElement);
  }, true); // Use capture phase to ensure it runs before other blur handlers


  formContact?.addEventListener('submit', async (event) => {
    event.preventDefault();
    formSubmissionErrorContact.classList.add('hidden'); // Hide previous errors

    let formIsValid = true;
    const formFields = formContact.querySelectorAll('input[required], textarea[required]');
    formFields.forEach(field => {
      // Validate all fields on submit, not just on input
      if (!validateField(field as HTMLInputElement | HTMLTextAreaElement)) {
        formIsValid = false;
      }
    });

    if (!formIsValid) {
      formSubmissionErrorContact.textContent = 'Please correct the highlighted fields.';
      formSubmissionErrorContact.classList.remove('hidden');
      // Find the first invalid field and focus it for accessibility
      const firstInvalidField = formContact.querySelector(':invalid');
      if (firstInvalidField) {
        (firstInvalidField as HTMLElement).focus();
      }
      return;
    }

    if (submitButtonContact) {
      submitButtonContact.disabled = true;
      submitButtonContact.textContent = 'Sending...';
      submitButtonContact.classList.add('opacity-70', 'cursor-not-allowed');
    }

    // reCAPTCHA integration
    if (import.meta.env.PROD && typeof grecaptcha !== 'undefined' && grecaptcha.ready) {
      try {
        const token = await grecaptcha.execute(import.meta.env.PUBLIC_RECAPTCHA_SITE_KEY, { action: 'submit_contact' });
        if (recaptchaInputContact) {
          recaptchaInputContact.value = token;
        } else {
          throw new Error('reCAPTCHA input field not found.');
        }
      } catch (error) {
        console.error('reCAPTCHA execution failed:', error);
        formSubmissionErrorContact.textContent = 'Failed to verify reCAPTCHA. Please try again.';
        formSubmissionErrorContact.classList.remove('hidden');
        if (submitButtonContact) {
          submitButtonContact.disabled = false;
          submitButtonContact.textContent = ctaText; // Revert to original CTA text
          submitButtonContact.classList.remove('opacity-70', 'cursor-not-allowed');
        }
        return;
      }
    } else if (import.meta.env.PROD) {
      // In production, if grecaptcha is not available, prevent submission
      console.error('reCAPTCHA script not loaded. Cannot submit form.');
      formSubmissionErrorContact.textContent = 'reCAPTCHA verification failed to load. Please refresh the page and try again.';
      formSubmissionErrorContact.classList.remove('hidden');
      if (submitButtonContact) {
        submitButtonContact.disabled = false;
        submitButtonContact.textContent = ctaText; // Revert to original CTA text
        submitButtonContact.classList.remove('opacity-70', 'cursor-not-allowed');
      }
      return;
    }

    // Prepare form data for fetch (assuming backend endpoint from TASK-024)
    const formData = new FormData(formContact);
    const data = Object.fromEntries(formData.entries());

    try {
      const response = await fetch('/api/submit-form', { // Assumed backend endpoint from TASK-024
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        // Display success message and clear form
        formSubmissionErrorContact.classList.remove('text-error');
        formSubmissionErrorContact.classList.add('text-success');
        formSubmissionErrorContact.textContent = 'Thank You! Your message has been sent to Joe. He aims to respond to all inquiries within 2 business days.';
        formSubmissionErrorContact.classList.remove('hidden');
        formContact.reset(); // Clear form fields
        // Clear validation messages and borders after successful submission
        formFields.forEach(field => {
          const errorElement = document.getElementById(`${field.id}-error`);
          if (errorElement) {
            errorElement.classList.add('hidden');
          }
          field.classList.remove('border-error');
        });
      } else {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Form submission failed.');
      }
    } catch (error) {
      console.error('Form submission error:', error);
      formSubmissionErrorContact.classList.remove('text-success');
      formSubmissionErrorContact.classList.add('text-error');
      formSubmissionErrorContact.textContent = error.message || 'There was an issue sending your message. Please try again or call Joe directly.';
      formSubmissionErrorContact.classList.remove('hidden');
    } finally {
      if (submitButtonContact) {
        submitButtonContact.disabled = false;
        submitButtonContact.textContent = ctaText; // Revert to original CTA text
        submitButtonContact.classList.remove('opacity-70', 'cursor-not-allowed');
      }
    }
  });
</script>